package main

import (
	"bytes"
	"context"
	"database/sql"
	"encoding/csv"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"

	"github.com/PaulSonOfLars/gotgbot/v2"
	"github.com/PaulSonOfLars/gotgbot/v2/ext"
	"github.com/PaulSonOfLars/gotgbot/v2/ext/handlers"
	"github.com/PaulSonOfLars/gotgbot/v2/ext/handlers/filters/callbackquery"
	"github.com/PaulSonOfLars/gotgbot/v2/ext/handlers/filters/chatmember"
	"github.com/PaulSonOfLars/gotgbot/v2/ext/handlers/filters/message"
	"github.com/caarlos0/env/v11"
	"github.com/mattn/go-sqlite3"
	"go.uber.org/zap"

	"main/minicv"
	"main/q"
)

type Config struct {
	BotToken string `env:"BOT_TOKEN,required,notEmpty"`

	DbPath        string `env:"MARS_DB_PATH,required,notEmpty"`
	ReportStatUrl string `env:"MARS_REPORT_STAT_URL"`
	LogLevel      string `env:"LOG_LEVEL" envDefault:"INFO"`

	BotBaseUrl     string   `env:"BOT_BASE_URL"`
	BotBaseFileUrl string   `env:"BOT_BASE_FILE_URL"`
	BotProxy       *url.URL `env:"BOT_PROXY"`

	NoBackup        bool   `env:"NO_BACKUP"`
	S3ApiEndpoint   string `env:"S3_API_ENDPOINT"`
	S3ApiKeyID      string `env:"S3_API_KEY_ID"`
	S3ApiKeySecret  string `env:"S3_API_KEY_SECRET"`
	S3Bucket        string `env:"S3_BUCKET"`
	S3BackupMinutes int    `env:"BACKUP_INTERVAL_MINUTES" envDefault:"2880"`

	DevMode bool `env:"DEV_MODE" envDefault:"false"`
}

var config Config

const (
	sqliteDriverName           = "marsbot_sqlite"
	groupedMediaWait           = 1 * time.Second
	mediaGroupLimit            = 10
	similarHDThreshold   int64 = 6
	exportCooldown             = 10 * time.Minute
	hammingDistanceError       = "dhash length mismatch"

	botRequestTimeout    = 15 * time.Second
	fileDownloadTimeout  = 20 * time.Second
	reportRequestTimeout = 10 * time.Second
	reportStatTimeout    = 5 * time.Second

	hammdistSOName = "libhammdist"
)

var (
	logger       *zap.Logger
	db           *sql.DB
	queries      *q.Queries
	fileClient   *http.Client
	reportClient *http.Client
	mediaMu      sync.Mutex
	mediaGroups  map[string]chan *gotgbot.Message

	exportMu           sync.Mutex
	exporting          map[int64]*exportState
	registerSQLiteOnce sync.Once
)

type marsResult struct {
	PrevCount     int64
	PrevLastMsgID int64
	Info          q.MarsInfo
	Skipped       bool
}

type exportState struct {
	running bool
	timer   *time.Timer
}

func main() {
	if err := env.Parse(&config); err != nil {
		fmt.Println(err.Error())
		os.Exit(2)
	}
	var err error
	logger, err = buildLogger(config.LogLevel)
	if err != nil {
		panic(err)
	}
	defer logger.Sync()
	go StartBackupThread()

	mediaGroups = make(map[string]chan *gotgbot.Message)
	exporting = make(map[int64]*exportState)

	if err := initDB(); err != nil {
		logger.Fatal("failed to start: init db", zap.Error(err))
	}
	bot, err := buildBot()
	if err != nil {
		logger.Fatal("failed to start: build bot", zap.Error(err))
	}

	dp := ext.NewDispatcher(&ext.DispatcherOpts{
		Error: func(_ *gotgbot.Bot, _ *ext.Context, err error) ext.DispatcherAction {
			logger.Warn("handler error", zap.Error(err))
			return ext.DispatcherActionNoop
		},
		Panic: func(_ *gotgbot.Bot, _ *ext.Context, r interface{}) {
			logger.Error("handler panic", zap.Any("r", r), zap.Stack("stack"))
		},
	})
	dp.AddHandler(handlers.NewMessage(message.Photo, handlePhoto).
		SetAllowChannel(true))
	dp.AddHandler(handlers.NewCallback(callbackquery.Prefix("wl:"), handleAddPicWhitelistByCallback))
	dp.AddHandler(handlers.NewCallback(callbackquery.Prefix("find:"), handleFindSimilarByCallback))
	dp.AddHandler(handlers.NewCommand("pic_info", handlePicInfo))
	dp.AddHandler(handlers.NewCommand("add_whitelist", handleAddToWhitelist))
	dp.AddHandler(handlers.NewCommand("remove_whitelist", handleRemoveFromWhitelist))
	dp.AddHandler(handlers.NewCommand("add_me_to_whitelist", handleAddUserToWhitelist))
	dp.AddHandler(handlers.NewCommand("remove_me_from_whitelist", handleRemoveUserFromWhitelist))
	dp.AddHandler(handlers.NewCommand("stat", handleBotStat))
	dp.AddHandler(handlers.NewCommand("help", handleHelp))
	dp.AddHandler(handlers.NewCommand("start", handleHelp))
	dp.AddHandler(handlers.NewCommand("mars_bot_welcome", handleCmdWelcome))
	dp.AddHandler(handlers.NewCommand("ensure_marsbot_export", handleExportData))
	dp.AddHandler(handlers.NewCommand("export", handleExportHelp))
	dp.AddHandler(handlers.NewMyChatMember(chatmember.All, handleWelcome))
	updater := ext.NewUpdater(dp, nil)

	allowed := []string{
		"callback_query",
		"channel_post",
		"message",
		"edited_message",
		"my_chat_member",
	}
	pollingOpts := &ext.PollingOpts{
		GetUpdatesOpts: &gotgbot.GetUpdatesOpts{
			AllowedUpdates: allowed,
		},
	}

	if err := updater.StartPolling(bot, pollingOpts); err != nil {
		logger.Fatal("failed to start polling", zap.Error(err))
	}
	logger.Info("marsbot is running", zap.String("username", bot.Username))
	updater.Idle()
}

func buildLogger(level string) (*zap.Logger, error) {
	var cfg zap.Config
	if config.DevMode {
		fmt.Println("Now running in dev mode")
		cfg = zap.NewDevelopmentConfig()
	} else {
		cfg = zap.NewProductionConfig()
	}
	if err := cfg.Level.UnmarshalText([]byte(strings.ToLower(level))); err != nil {
		cfg.Level = zap.NewAtomicLevelAt(zap.InfoLevel)
	}
	return cfg.Build()
}

func registerSQLiteDriver() {
	registerSQLiteOnce.Do(func() {
		f, err := os.Executable()
		hammdistSOFile := hammdistSOName
		if err == nil {
			hammdistSOFile = filepath.Join(filepath.Dir(f), hammdistSOName)
		}
		sql.Register(sqliteDriverName, &sqlite3.SQLiteDriver{
			ConnectHook: func(conn *sqlite3.SQLiteConn) error {
				err := conn.LoadExtension(hammdistSOFile, "sqlite3_hammdist_init")
				if err == nil {
					fmt.Println("hammdist.so loaded")
					return nil
				}
				fmt.Println("loaded hammdist.so failed, err: " + err.Error())
				return conn.RegisterFunc("hamming_distance", hammingDistance, true)
			},
		})
	})
}

func initDB() error {
	registerSQLiteDriver()
	var err error
	db, err = sql.Open(sqliteDriverName, config.DbPath)
	if err != nil {
		return fmt.Errorf("open database: %w", err)
	}
	pragmas := []string{
		"PRAGMA journal_mode=WAL;",
		"PRAGMA synchronous=OFF;",
		"PRAGMA cache_size=-80000;",
		"PRAGMA busy_timeout=5000;",
	}
	for _, p := range pragmas {
		if _, err := db.Exec(p); err != nil {
			db.Close()
			return fmt.Errorf("apply pragma %q: %w", p, err)
		}
	}
	queries = q.NewWithLogger(db, logger)
	return nil
}

func buildBot() (*gotgbot.Bot, error) {
	transport := &http.Transport{}
	if config.BotProxy != nil {
		transport.Proxy = http.ProxyURL(config.BotProxy)
	}

	fileClient = &http.Client{
		Timeout:   fileDownloadTimeout,
		Transport: transport,
	}
	if config.ReportStatUrl != "" {
		reportClient = &http.Client{
			Timeout: reportRequestTimeout,
		}
	}
	client := &gotgbot.BaseBotClient{
		Client: http.Client{
			Timeout:   botRequestTimeout,
			Transport: fileClient.Transport,
		},
	}
	if config.BotBaseUrl != "" {
		client.DefaultRequestOpts = &gotgbot.RequestOpts{APIURL: config.BotBaseUrl}
	}
	bot, err := gotgbot.NewBot(config.BotToken, &gotgbot.BotOpts{BotClient: client})
	if err != nil {
		return nil, fmt.Errorf("create bot: %w", err)
	}
	return bot, err
}

func handlePhoto(bot *gotgbot.Bot, ctx *ext.Context) error {
	msg := ctx.EffectiveMessage
	chat := ctx.EffectiveChat
	if msg == nil || chat == nil || len(msg.Photo) == 0 {
		return nil
	}
	// skip edited grouped media to avoid double counting
	if msg.MediaGroupId != "" && ctx.EditedMessage != nil {
		return nil
	}

	if ctx.EffectiveUser != nil {
		inWl, err := isUserInWhitelist(context.Background(), chat.Id, ctx.EffectiveUser.Id)
		if err != nil {
			logger.Warn("check user whitelist", zap.Error(err))
		}
		if inWl {
			return nil
		}
	}

	if msg.MediaGroupId != "" {
		enqueueMediaGroup(bot, msg)
		return nil
	}
	return processSinglePhoto(bot, msg)
}

func processSinglePhoto(bot *gotgbot.Bot, msg *gotgbot.Message) error {
	ctx := context.Background()
	photo := msg.Photo[len(msg.Photo)-1]
	dhash, err := getDHash(ctx, bot, photo)
	if err != nil {
		return err
	}
	result, err := recordMars(ctx, msg.Chat.Id, msg.MessageId, dhash)
	if err != nil {
		return err
	}
	if result.Skipped || result.PrevCount == 0 {
		return nil
	}

	reply := buildMarsReply(&msg.Chat, result.PrevCount, result.PrevLastMsgID)
	opt := &gotgbot.SendMessageOpts{
		ReplyParameters: replyTo(msg.MessageId),
		ParseMode:       "HTML",
	}
	if result.PrevCount > 3 {
		opt.ReplyMarkup = &gotgbot.InlineKeyboardMarkup{
			InlineKeyboard: [][]gotgbot.InlineKeyboardButton{{
				{
					Text:         "å°†å›¾ç‰‡æ·»åŠ è‡³ç™½åå•",
					CallbackData: fmt.Sprintf("wl:%s", hex.EncodeToString(dhash)),
				},
			}},
		}
	}
	_, err = bot.SendMessage(msg.Chat.Id, reply, opt)
	if err != nil {
		logger.Warn("send mars reply", zap.Error(err))
	}
	go reportStat(msg.Chat.Id, result.PrevCount)
	return nil
}

func enqueueMediaGroup(bot *gotgbot.Bot, msg *gotgbot.Message) {
	mediaMu.Lock()
	defer mediaMu.Unlock()
	c, ok := mediaGroups[msg.MediaGroupId]
	if !ok {
		c = make(chan *gotgbot.Message, mediaGroupLimit)
		mediaGroups[msg.MediaGroupId] = c
		go flushMediaGroup(bot, msg.MediaGroupId, c)
	}
	select {
	case c <- msg:
	default:
	}
}

func flushMediaGroup(bot *gotgbot.Bot, groupID string, c chan *gotgbot.Message) {
	defer func() {
		mediaMu.Lock()
		delete(mediaGroups, groupID)
		mediaMu.Unlock()
	}()
	msgs := make([]*gotgbot.Message, 0, mediaGroupLimit)
	timer := time.NewTimer(groupedMediaWait)
	defer timer.Stop()
loop:
	for {
		select {
		case msg := <-c:
			msgs = append(msgs, msg)
			timer.Reset(groupedMediaWait)
		case <-timer.C:
			break loop
		}
	}
	if err := handleMediaGroup(bot, msgs); err != nil {
		logger.Warn("handle media group", zap.Error(err), zap.String("group_id", groupID))
	}
}

func handleMediaGroup(bot *gotgbot.Bot, msgs []*gotgbot.Message) error {
	ctx := context.Background()
	type item struct {
		msg *gotgbot.Message
		res marsResult
	}
	unique := make(map[string]*item)

	for _, msg := range msgs {
		if len(msg.Photo) == 0 {
			continue
		}
		dhash, err := getDHash(ctx, bot, msg.Photo[len(msg.Photo)-1])
		if err != nil {
			logger.Warn("get dhash for group media", zap.Error(err))
			continue
		}
		key := hex.EncodeToString(dhash)
		if _, ok := unique[key]; ok {
			continue // avoid duplicate reporting inside one album
		}
		res, err := recordMars(ctx, msg.Chat.Id, msg.MessageId, dhash)
		if err != nil {
			logger.Warn("record mars for group media", zap.Error(err))
			continue
		}
		unique[key] = &item{msg: msg, res: res}
		if res.PrevCount > 0 && !res.Skipped {
			go reportStat(msg.Chat.Id, res.PrevCount)
		}
	}

	var best *item
	for _, it := range unique {
		if it.res.Skipped || it.res.PrevCount == 0 {
			continue
		}
		if best == nil || it.res.PrevCount > best.res.PrevCount {
			best = it
		}
	}
	if best == nil {
		return nil
	}
	reply := buildGroupedReply(&best.msg.Chat, best.res.PrevCount, best.res.PrevLastMsgID)
	_, err := bot.SendMessage(best.msg.Chat.Id, reply, &gotgbot.SendMessageOpts{
		ReplyParameters: replyTo(best.msg.MessageId),
		ParseMode:       "HTML",
	})
	return err
}

func getDHash(ctx context.Context, b *gotgbot.Bot, photo gotgbot.PhotoSize) ([]byte, error) {
	dhash, err := queries.GetDhashFromFileUid(ctx, photo.FileUniqueId)
	if err == nil {
		return dhash, nil
	}
	if !errors.Is(err, sql.ErrNoRows) {
		return nil, err
	}

	file, err := b.GetFile(photo.FileId, nil)
	if err != nil {
		return nil, fmt.Errorf("get file: %w", err)
	}
	var data []byte
	if data2, err := os.ReadFile(file.FilePath); err == nil {
		data = data2
	} else {
		u := file.URL(b, &gotgbot.RequestOpts{APIURL: config.BotBaseFileUrl})
		data, err = downloadFile(ctx, u)
		if err != nil {
			return nil, err
		}
	}
	dhashArr, err := minicv.DHashBytes(data)
	if err != nil {
		return nil, err
	}
	dhash = dhashArr[:]
	if err := queries.UpsertDhash(ctx, photo.FileUniqueId, dhash); err != nil {
		logger.Warn("cache dhash", zap.Error(err))
	}
	return dhash, nil
}

func downloadFile(ctx context.Context, url string) ([]byte, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
	if err != nil {
		return nil, fmt.Errorf("build request: %w", err)
	}
	resp, err := fileClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("download file: %w", err)
	}
	defer resp.Body.Close()
	if resp.StatusCode >= 400 {
		return nil, fmt.Errorf("download failed with status %s", resp.Status)
	}
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("read file: %w", err)
	}
	return body, nil
}

func recordMars(ctx context.Context, groupID, msgID int64, dhash []byte) (marsResult, error) {
	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return marsResult{}, err
	}
	qtx := queries.WithTx(tx)

	info, err := qtx.GetMarsInfo(ctx, groupID, dhash)
	prevCount := int64(0)
	prevLastMsgID := int64(0)
	if err == nil {
		prevCount = info.Count
		prevLastMsgID = info.LastMsgID
		if info.LastMsgID == msgID || info.InWhitelist != 0 {
			_ = tx.Rollback()
			return marsResult{PrevCount: prevCount, PrevLastMsgID: prevLastMsgID, Info: info, Skipped: true}, nil
		}
	} else if !errors.Is(err, sql.ErrNoRows) {
		_ = tx.Rollback()
		return marsResult{}, err
	}

	newInfo, err := qtx.IncrementMarsInfo(ctx, groupID, dhash, msgID)
	if err != nil {
		_ = tx.Rollback()
		return marsResult{}, err
	}
	if prevCount == 0 {
		if err := qtx.IncrementGroupStat(ctx, groupID); err != nil {
			_ = tx.Rollback()
			return marsResult{}, err
		}
	}
	if err := tx.Commit(); err != nil {
		return marsResult{}, err
	}
	return marsResult{
		PrevCount:     prevCount,
		PrevLastMsgID: prevLastMsgID,
		Info:          newInfo,
	}, nil
}

func isUserInWhitelist(ctx context.Context, groupID, userID int64) (bool, error) {
	val, err := queries.IsUserInWhitelist(ctx, groupID, userID)
	if err != nil {
		return false, err
	}
	return val != 0, nil
}

func reportStat(groupID int64, marsCount int64) {
	if reportClient == nil || config.ReportStatUrl == "" {
		return
	}
	ctx, cancel := context.WithTimeout(context.Background(), reportStatTimeout)
	defer cancel()
	body, _ := json.Marshal(map[string]int64{
		"group_id":   groupID,
		"mars_count": marsCount,
	})
	req, err := http.NewRequestWithContext(ctx, http.MethodPost, config.ReportStatUrl, bytes.NewReader(body))
	if err != nil {
		logger.Warn("build report request", zap.Error(err))
		return
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := reportClient.Do(req)
	if err != nil {
		logger.Warn("report stat", zap.Error(err))
		return
	}
	_ = resp.Body.Close()
}

func handleAddPicWhitelistByCallback(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.CallbackQuery == nil || ctx.EffectiveChat == nil {
		return nil
	}
	dhash, err := parseCallback(ctx.CallbackQuery.Data)
	if err != nil {
		_, err = ctx.CallbackQuery.Answer(b, &gotgbot.AnswerCallbackQueryOpts{Text: err.Error()})
		return err
	}
	if err := queries.SetMarsWhitelist(context.Background(), ctx.EffectiveChat.Id, dhash, 1); err != nil {
		return err
	}
	_, err = ctx.CallbackQuery.Answer(b, &gotgbot.AnswerCallbackQueryOpts{Text: "è¯¥å›¾ç‰‡å·²åŠ å…¥ç™½åå•"})
	return err
}

func handlePicInfo(b *gotgbot.Bot, ctx *ext.Context) error {
	msg := ctx.EffectiveMessage
	if msg == nil || ctx.EffectiveChat == nil {
		return nil
	}
	photo := getReferPhoto(msg)
	if photo == nil {
		_, err := b.SendMessage(ctx.EffectiveChat.Id, "ç«æ˜Ÿè½¦æ²¡æœ‰å‘ç°æ‚¨å¼•ç”¨äº†ä»»ä½•å›¾ç‰‡ã€‚\nå°è¯•å‘é€å›¾ç‰‡ä½¿ç”¨å‘½ä»¤ï¼Œæˆ–å›å¤ç‰¹å®šå›¾ç‰‡ã€‚",
			&gotgbot.SendMessageOpts{ReplyParameters: replyTo(msg.MessageId)})
		return err
	}

	dhash, err := getDHash(context.Background(), b, *photo)
	if err != nil {
		return err
	}
	info, err := queries.GetMarsInfo(context.Background(), ctx.EffectiveChat.Id, dhash)
	if errors.Is(err, sql.ErrNoRows) {
		info = q.MarsInfo{GroupID: ctx.EffectiveChat.Id, PicDhash: dhash, Count: 0, LastMsgID: 0, InWhitelist: 0}
	} else if err != nil {
		return err
	}

	whitelistStr := "ğŸŸ¢ å®ƒä¸åœ¨æœ¬ç¾¤çš„ç«æ˜Ÿç™½åå•å½“ä¸­"
	if info.InWhitelist != 0 {
		whitelistStr = "ğŸ™ˆ å®ƒåœ¨æœ¬ç¾¤çš„ç«æ˜Ÿç™½åå•ä¸­"
	}
	markup := &gotgbot.InlineKeyboardMarkup{
		InlineKeyboard: [][]gotgbot.InlineKeyboardButton{{
			{Text: "æŸ¥æ‰¾DHASHç›¸ä¼¼å›¾ç‰‡", CallbackData: fmt.Sprintf("find:%s", hex.EncodeToString(dhash))},
		}},
	}

	_, err = b.SendMessage(ctx.EffectiveChat.Id, fmt.Sprintf("File unique id: %s\n"+
		"dhash: %s\nåœ¨æœ¬ç¾¤çš„ç«æ˜Ÿæ¬¡æ•°:%d\n%s",
		photo.FileUniqueId, strings.ToUpper(hex.EncodeToString(dhash)), info.Count, whitelistStr),
		&gotgbot.SendMessageOpts{
			ReplyParameters: replyTo(msg.MessageId),
			ReplyMarkup:     markup,
		})
	return err
}

func handleAddToWhitelist(b *gotgbot.Bot, ctx *ext.Context) error {
	return updateWhitelistForPhoto(b, ctx, true)
}

func handleRemoveFromWhitelist(b *gotgbot.Bot, ctx *ext.Context) error {
	return updateWhitelistForPhoto(b, ctx, false)
}

func updateWhitelistForPhoto(b *gotgbot.Bot, ctx *ext.Context, toWhitelist bool) error {
	msg := ctx.EffectiveMessage
	if msg == nil || ctx.EffectiveChat == nil || b == nil {
		return nil
	}
	photo := getReferPhoto(msg)
	if photo == nil {
		_, err := b.SendMessage(ctx.EffectiveChat.Id, "ç«æ˜Ÿè½¦æ²¡æœ‰å‘ç°æ‚¨å¼•ç”¨äº†ä»»ä½•å›¾ç‰‡ã€‚\nå°è¯•å‘é€å›¾ç‰‡ä½¿ç”¨å‘½ä»¤ï¼Œæˆ–å›å¤ç‰¹å®šå›¾ç‰‡ã€‚",
			&gotgbot.SendMessageOpts{ReplyParameters: replyTo(msg.MessageId)})
		return err
	}
	dhash, err := getDHash(context.Background(), b, *photo)
	if err != nil {
		return err
	}
	info, err := queries.GetMarsInfo(context.Background(), ctx.EffectiveChat.Id, dhash)
	if errors.Is(err, sql.ErrNoRows) {
		info = q.MarsInfo{InWhitelist: 0}
	} else if err != nil {
		return err
	}
	if toWhitelist && info.InWhitelist != 0 {
		_, err := b.SendMessage(ctx.EffectiveChat.Id, "è¿™å¼ å›¾ç‰‡å·²ç»åœ¨ç™½åå•å½“ä¸­äº†",
			&gotgbot.SendMessageOpts{ReplyParameters: replyTo(msg.MessageId)})
		return err
	}
	if !toWhitelist && info.InWhitelist == 0 {
		_, err := b.SendMessage(ctx.EffectiveChat.Id, "è¿™å¼ å›¾ç‰‡å¹¶ä¸åœ¨ç™½åå•ä¸­",
			&gotgbot.SendMessageOpts{ReplyParameters: replyTo(msg.MessageId)})
		return err
	}
	flag := int64(0)
	successMsg := "æˆåŠŸå°†å›¾ç‰‡ç§»é™¤ç™½åå•"
	if toWhitelist {
		flag = 1
		successMsg = "æˆåŠŸå°†å›¾ç‰‡åŠ å…¥ç™½åå•"
	}
	if err := queries.SetMarsWhitelist(context.Background(), ctx.EffectiveChat.Id, dhash, flag); err != nil {
		return err
	}
	_, err = b.SendMessage(ctx.EffectiveChat.Id, successMsg, &gotgbot.SendMessageOpts{ReplyParameters: replyTo(msg.MessageId)})
	return err
}

func handleAddUserToWhitelist(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.EffectiveChat == nil || ctx.EffectiveUser == nil || ctx.EffectiveMessage == nil {
		return nil
	}
	err := queries.AddUserToWhitelist(context.Background(), ctx.EffectiveChat.Id, ctx.EffectiveUser.Id)
	if err != nil {
		var sqliteErr sqlite3.Error
		if errors.As(err, &sqliteErr) && errors.Is(sqliteErr.Code, sqlite3.ErrConstraint) {
			_, sendErr := b.SendMessage(ctx.EffectiveChat.Id, fmt.Sprintf("ç”¨æˆ· %s å·²ç»åœ¨æœ¬ç¾¤çš„ç™½åå•ä¸­ï¼Œæ‚¨å‘çš„ä»»ä½•å›¾ç‰‡éƒ½ä¸ä¼šè¢«å¤„ç†ã€‚", ctx.EffectiveMessage.GetSender().Name()),
				&gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
			return sendErr
		}
		return err
	}
	name := ctx.EffectiveMessage.GetSender().Name()
	_, err = b.SendMessage(ctx.EffectiveChat.Id, fmt.Sprintf("å·²å°†ç”¨æˆ· %s åŠ å…¥ç™½åå•ï¼Œæ‚¨å‘çš„ä»»ä½•å›¾ç‰‡éƒ½ä¸ä¼šè¢«å¤„ç†ã€‚", name),
		&gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
	return err
}

func handleRemoveUserFromWhitelist(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.EffectiveChat == nil || ctx.EffectiveUser == nil || ctx.EffectiveMessage == nil {
		return nil
	}
	err := queries.DeleteUserFromWhitelist(context.Background(), ctx.EffectiveChat.Id, ctx.EffectiveUser.Id)
	if err != nil {
		return err
	}
	_, err = b.SendMessage(ctx.EffectiveChat.Id, fmt.Sprintf("å·²å°†ç”¨æˆ· %s ç§»é™¤æœ¬ç¾¤ç™½åå•ï¼Œç«æ˜Ÿè½¦ä¼šç»§ç»­ä¸ºæ‚¨æœåŠ¡ã€‚",
		ctx.EffectiveMessage.GetSender().Name()),
		&gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
	return err
}

func handleBotStat(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.EffectiveChat == nil || ctx.EffectiveUser == nil || ctx.EffectiveMessage == nil {
		return nil
	}
	start := time.Now()
	groupCount, err := queries.CountGroups(context.Background())
	if err != nil {
		groupCount = 0
	}
	marsCount, err := queries.GetGroupMarsCount(context.Background(), ctx.EffectiveChat.Id)
	if err != nil && !errors.Is(err, sql.ErrNoRows) {
		return err
	}
	inWhitelist, err := isUserInWhitelist(context.Background(), ctx.EffectiveChat.Id, ctx.EffectiveUser.Id)
	if err != nil {
		return err
	}
	exists := "ä¸åœ¨"
	if inWhitelist {
		exists = "åœ¨"
	}
	duration := time.Since(start)
	_, err = b.SendMessage(ctx.EffectiveChat.Id, fmt.Sprintf("ç«æ˜Ÿè½¦å½“å‰ä¸€å…±æœåŠ¡äº†%dä¸ªç¾¤ç»„\n"+
		"å½“å‰ç¾¤ç»„ID: %d\n"+
		"æ‚¨æ˜¯ %s(id:%d)ï¼Œæ‚¨%sæœ¬ç¾¤çš„ç™½åå•å½“ä¸­\n"+
		"æœ¬ç¾¤ä¸€å…±è®°å½•äº† %d å¼ ä¸åŒçš„å›¾ç‰‡\n"+
		"æœ¬æ¬¡ç»Ÿè®¡å…±è€—æ—¶ %s\n"+
		"ç«æ˜Ÿè½¦ä¸æ‚¨åŒåœ¨",
		groupCount, ctx.EffectiveChat.Id, ctx.EffectiveMessage.GetSender().Name(), ctx.EffectiveUser.Id, exists, marsCount, duration),
		&gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
	return err
}

func handleHelp(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.EffectiveChat == nil || ctx.EffectiveMessage == nil {
		return nil
	}
	if ctx.EffectiveChat.Type != "private" && strings.HasPrefix(ctx.EffectiveMessage.GetText(), "/start") {
		return nil
	}
	atSuffix := ""
	if ctx.EffectiveChat.Type != "private" && b != nil {
		atSuffix = "@" + b.Username
	}
	_, err := b.SendMessage(ctx.EffectiveChat.Id,
		strings.ReplaceAll("/help@botname æ˜¾ç¤ºæœ¬å¸®åŠ©ä¿¡æ¯\n"+
			"/stat@botname æ˜¾ç¤ºç»Ÿè®¡ä¿¡æ¯\n"+
			"/pic_info@botname è·å–å›¾ç‰‡ä¿¡æ¯\n"+
			"/add_whitelist@botname å°†å›¾ç‰‡æ·»åŠ åˆ°ç™½åå•\n"+
			"/remove_whitelist@botname å°†å›¾ç‰‡ç§»é™¤ç™½åå•\n"+
			"/add_me_to_whitelist@botname å°†ç”¨æˆ·åŠ å…¥ç¾¤ç»„ç™½åå•\n"+
			"/remove_me_from_whitelist@botname å°†ç”¨æˆ·ç§»å‡ºç¾¤ç»„ç™½åå•\n"+
			"/export@botname å¯¼å‡ºç«æ˜Ÿè½¦çš„å¸®åŠ©ä¿¡æ¯", "@botname", atSuffix),
		&gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
	return err
}

func handleWelcome(b *gotgbot.Bot, ctx *ext.Context) error {
	update := ctx.MyChatMember
	if update == nil || update.Chat.Type == "private" {
		return nil
	}
	if update.Chat.Type != "channel" && update.NewChatMember.GetStatus() == "administrator" {
		_, err := b.SendMessage(update.Chat.Id, "ç«æ˜Ÿè½¦çš„ä»»ä½•åŠŸèƒ½å‡ä¸éœ€è¦ç®¡ç†å‘˜æƒé™ï¼Œæ‚¨æ— éœ€å°†æœ¬botè®¾ç½®ä¸ºç¾¤ç»„ç®¡ç†å‘˜ã€‚", nil)
		return err
	}
	oldStatus := update.OldChatMember.GetStatus()
	if oldStatus != "left" && oldStatus != "kicked" {
		return nil
	}
	if update.NewChatMember.GetStatus() == "member" {
		return sendWelcome(b, update.Chat.Id)
	}
	return nil
}

func handleCmdWelcome(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.EffectiveChat == nil {
		return nil
	}
	return sendWelcome(b, ctx.EffectiveChat.Id)
}

func sendWelcome(bot *gotgbot.Bot, chatID int64) error {
	_, err := bot.SendMessage(chatID,
		"æ¬¢è¿ä½¿ç”¨ç«æ˜Ÿè½¦ã€‚\n"+
			"æœ¬botä¸º @Ytyan ä¸ºå…¶ç¾¤ç»„å¼€å‘çš„é‡å¤å›¾ç‰‡æ£€æµ‹å·¥å…·\n"+
			"å½“æ‚¨å°†ç«æ˜Ÿè½¦åŠ å…¥ç¾¤ç»„æˆ–é¢‘é“ä¸­åï¼Œç«æ˜Ÿè½¦å°†è‡ªåŠ¨å¼€å§‹å·¥ä½œã€‚botä¼šå®æ—¶æ£€æµ‹ç¾¤ç»„ä¸­çš„å›¾ç‰‡ï¼Œå°†å…¶è½¬æ¢ä¸ºDHASHï¼Œå½“æ£€æµ‹åˆ°é‡å¤å›¾ç‰‡æ—¶ï¼Œä¼šå›å¤å›¾ç‰‡çš„å‘é€è€…ã€‚\n"+
			"botä¼šæ”¶é›†å¹¶æŒä¹…ä¿å­˜å·¥ä½œéœ€è¦çš„å¿…è¦ä¿¡æ¯ï¼ŒåŒ…æ‹¬ç¾¤ç»„IDã€å›¾ç‰‡å”¯ä¸€IDã€å›¾ç‰‡DHASHå’Œæºå¸¦å›¾ç‰‡çš„æ¶ˆæ¯çš„IDã€‚botä¼šåœ¨å¿…è¦æ—¶ä¸‹è½½å›¾ç‰‡ï¼Œä½†ä¸ä¼šæŒä¹…ä¿å­˜\n"+
			"botåªä¼šæ£€æŸ¥æ™®é€šå›¾ç‰‡ï¼Œæ–‡ä»¶å½¢å¼çš„å›¾ç‰‡ã€è¡¨æƒ…åŒ…ã€è§†é¢‘ç­‰å‡ä¸ä¼šè¢«æ£€æµ‹ã€‚\n"+
			`æœ¬botä¸ºå¼€æºé¡¹ç›®ï¼Œæ‚¨å¯ä»¥å‰å¾€<a href="https://github.com/zytyan/pymarsbot">Githubå¼€æºåœ°å€</a>è‡ªè¡Œå…‹éš†è¯¥é¡¹ç›®ã€‚`,
		&gotgbot.SendMessageOpts{ParseMode: "HTML"})
	return err
}

func handleExportData(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.EffectiveChat == nil || ctx.EffectiveMessage == nil {
		return nil
	}
	chatID := ctx.EffectiveChat.Id

	exportMu.Lock()
	state, ok := exporting[chatID]
	if ok {
		if state.running {
			exportMu.Unlock()
			_, err := b.SendMessage(chatID, "å½“å‰æ­£åœ¨å¯¼å‡ºæ•°æ®ï¼Œè¯·ç¨å€™å†è¯•", &gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
			return err
		}
		exportMu.Unlock()
		_, err := b.SendMessage(chatID, "è¯·ä¸è¦çŸ­æ—¶é—´å†…é‡å¤å¯¼å‡ºï¼Œæ¯æ¬¡å•ä¸ªç¾¤ç»„å¯¼å‡ºå†·å´æ—¶é—´ä¸º10åˆ†é’Ÿã€‚", &gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
		return err
	}
	state = &exportState{running: true}
	exporting[chatID] = state
	exportMu.Unlock()

	filePath, err := exportChatData(chatID)
	if err != nil {
		exportMu.Lock()
		delete(exporting, chatID)
		exportMu.Unlock()
		return err
	}
	defer os.Remove(filePath)

	f, err := os.Open(filePath)
	if err != nil {
		return err
	}
	defer f.Close()

	_, err = b.SendDocument(chatID, gotgbot.InputFileByReader(filepath.Base(filePath), f),
		&gotgbot.SendDocumentOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
	if err != nil {
		exportMu.Lock()
		delete(exporting, chatID)
		exportMu.Unlock()
		return err
	}

	exportMu.Lock()
	state.running = false
	state.timer = time.AfterFunc(exportCooldown, func() {
		exportMu.Lock()
		delete(exporting, chatID)
		exportMu.Unlock()
	})
	exportMu.Unlock()
	return nil
}

func exportChatData(chatID int64) (string, error) {
	rows, err := queries.ListMarsInfoByGroup(context.Background(), chatID)
	if err != nil {
		return "", err
	}
	filename := filepath.Join(os.TempDir(), fmt.Sprintf("mars-export_%d.csv", chatID))
	file, err := os.Create(filename)
	if err != nil {
		return "", err
	}
	defer file.Close()

	writer := csv.NewWriter(file)
	defer writer.Flush()

	if err := writer.Write([]string{"group_id", "pic_dhash", "count", "last_msg_id", "in_whitelist"}); err != nil {
		return "", err
	}
	for _, row := range rows {
		record := []string{
			fmt.Sprint(row.GroupID),
			hex.EncodeToString(row.PicDhash),
			fmt.Sprint(row.Count),
			fmt.Sprint(row.LastMsgID),
			fmt.Sprint(row.InWhitelist),
		}
		if err := writer.Write(record); err != nil {
			return "", err
		}
	}
	return filename, nil
}

func handleExportHelp(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.EffectiveMessage == nil || ctx.EffectiveChat == nil {
		return nil
	}
	_, err := b.SendMessage(ctx.EffectiveChat.Id, "æƒ³éƒ¨ç½²è‡ªå·±çš„ç«æ˜Ÿè½¦ï¼Œåˆæ”¾ä¸ä¸‹å½“å‰æ•°æ®ï¼Ÿ\nç°åœ¨ï¼Œæ‚¨å¯ä»¥ä½¿ç”¨å‘½ä»¤ /ensure_marsbot_export å¯¼å‡ºç«æ˜Ÿè½¦çš„æ•°æ®ï¼Œå®ƒä»¬åŒ…æ‹¬ç¾¤ç»„IDã€DHASHå€¼ã€ç«æ˜Ÿæ•°é‡ã€ä¸Šä¸€æ¬¡æ¶ˆæ¯IDåŠç™½åå•çŠ¶æ€\nè¿™äº›ä¿¡æ¯å°†ä¼šè¢«å¯¼å‡ºä¸ºcsvæ ¼å¼ï¼Œæ‚¨å¯ä»¥åœ¨è§£å‹åæ”¾å¿ƒåœ°ç›´æ¥ä½¿ç”¨é€—å·åˆ†å‰²ã€‚\nè¯·æ³¨æ„ï¼Œä¸ºé¿å…æ— æ„ä¹‰çš„æ€§èƒ½æ¶ˆè€—ï¼Œæ¯ä¸ªç¾¤ç»„åœ¨ååˆ†é’Ÿå†…åªèƒ½å¯¼å‡ºä¸€æ¬¡ã€‚",
		&gotgbot.SendMessageOpts{ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId)})
	return err
}

func handleFindSimilarByCallback(b *gotgbot.Bot, ctx *ext.Context) error {
	if ctx.CallbackQuery == nil || ctx.EffectiveChat == nil || ctx.EffectiveMessage == nil {
		return nil
	}
	target, err := parseCallback(ctx.CallbackQuery.Data)
	if err != nil {
		_, err = ctx.CallbackQuery.Answer(b, &gotgbot.AnswerCallbackQueryOpts{Text: err.Error()})
		return err
	}

	start := time.Now()
	items, err := queries.ListSimilarPhotos(context.Background(), target, ctx.EffectiveChat.Id, similarHDThreshold)
	if err != nil {
		return err
	}
	var textLines []string
	textLines = append(textLines, fmt.Sprintf("ç«æ˜Ÿè½¦ä¸ºæ‚¨æ‰¾åˆ°äº†%då¼ ç›¸ä¼¼çš„å›¾ç‰‡\nè¿™äº›å›¾ç‰‡çš„æ±‰æ˜è·ç¦»å°äº%d\nè€—æ—¶:%s\n",
		len(items), similarHDThreshold, time.Since(start)))
	for i, item := range items {
		startLabel, endLabel := buildLabel(ctx.EffectiveChat, item.MarsInfo.LastMsgID)
		textLines = append(textLines, fmt.Sprintf("%så›¾ç‰‡%d: è·ç¦»: %d æ¶ˆæ¯ID: %d%s", startLabel, i+1, item.Hd, item.MarsInfo.LastMsgID, endLabel))
	}
	_, err = b.SendMessage(ctx.EffectiveChat.Id, strings.Join(textLines, "\n"),
		&gotgbot.SendMessageOpts{
			ReplyParameters: replyTo(ctx.EffectiveMessage.MessageId),
			ParseMode:       "HTML",
		})
	if err != nil {
		return err
	}
	_, err = ctx.CallbackQuery.Answer(b, &gotgbot.AnswerCallbackQueryOpts{Text: "æŸ¥æ‰¾å®Œæˆ", ShowAlert: false})
	return err
}

func parseCallback(s string) ([]byte, error) {
	parts := strings.SplitN(s, ":", 2)
	if len(parts) != 2 {
		return nil, errors.New("not valid callback")
	}
	return hex.DecodeString(parts[1])
}
