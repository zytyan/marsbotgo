// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query_mars.sql

package q

import (
	"context"
	"time"

	"go.uber.org/zap"
)

const addUserToWhitelist = `-- name: AddUserToWhitelist :exec
INSERT INTO group_user_in_whitelist(group_id, user_id)
VALUES (?, ?)
`

func (q *Queries) AddUserToWhitelist(ctx context.Context, groupID int64, userID int64) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("group_id", groupID),
					zap.Int64("user_id", userID),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.addUserToWhitelistStmt, addUserToWhitelist, groupID, userID)
	q.logQuery(addUserToWhitelist, "AddUserToWhitelist", logFields, err, start)
	return err
}

const deleteUserFromWhitelist = `-- name: DeleteUserFromWhitelist :exec
DELETE
FROM group_user_in_whitelist
WHERE group_id = ?
  AND user_id = ?
`

func (q *Queries) DeleteUserFromWhitelist(ctx context.Context, groupID int64, userID int64) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("group_id", groupID),
					zap.Int64("user_id", userID),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.deleteUserFromWhitelistStmt, deleteUserFromWhitelist, groupID, userID)
	q.logQuery(deleteUserFromWhitelist, "DeleteUserFromWhitelist", logFields, err, start)
	return err
}

const getDhashFromFileUid = `-- name: GetDhashFromFileUid :one
SELECT dhash
FROM fuid_to_dhash
WHERE fuid = ?
`

func (q *Queries) GetDhashFromFileUid(ctx context.Context, fuid string) ([]byte, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.String("fuid", fuid),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getDhashFromFileUidStmt, getDhashFromFileUid, fuid)
	var dhash []byte
	err := row.Scan(&dhash)
	q.logQuery(getDhashFromFileUid, "GetDhashFromFileUid", logFields, err, start)
	return dhash, err
}

const getMarsInfo = `-- name: GetMarsInfo :one
SELECT group_id, pic_dhash, count, last_msg_id, in_whitelist
FROM mars_info
WHERE group_id = ?
  AND pic_dhash = ?
`

func (q *Queries) GetMarsInfo(ctx context.Context, groupID int64, picDhash []byte) (MarsInfo, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("group_id", groupID),
					zap.ByteString("pic_dhash", picDhash),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.getMarsInfoStmt, getMarsInfo, groupID, picDhash)
	var i MarsInfo
	err := row.Scan(
		&i.GroupID,
		&i.PicDhash,
		&i.Count,
		&i.LastMsgID,
		&i.InWhitelist,
	)
	q.logQuery(getMarsInfo, "GetMarsInfo", logFields, err, start)
	return i, err
}

const isUserInWhitelist = `-- name: IsUserInWhitelist :one
SELECT EXISTS (SELECT 1 FROM group_user_in_whitelist WHERE group_id = ? AND user_id = ?)
`

func (q *Queries) IsUserInWhitelist(ctx context.Context, groupID int64, userID int64) (int64, error) {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("group_id", groupID),
					zap.Int64("user_id", userID),
				),
			)
		}
	}
	row := q.queryRow(ctx, q.isUserInWhitelistStmt, isUserInWhitelist, groupID, userID)
	var column_1 int64
	err := row.Scan(&column_1)
	q.logQuery(isUserInWhitelist, "IsUserInWhitelist", logFields, err, start)
	return column_1, err
}

const upsertDhash = `-- name: UpsertDhash :exec
INSERT INTO fuid_to_dhash (fuid, dhash)
VALUES (?, ?)
ON CONFLICT DO UPDATE SET dhash=excluded.dhash
`

func (q *Queries) UpsertDhash(ctx context.Context, fuid string, dhash []byte) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.String("fuid", fuid),
					zap.ByteString("dhash", dhash),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.upsertDhashStmt, upsertDhash, fuid, dhash)
	q.logQuery(upsertDhash, "UpsertDhash", logFields, err, start)
	return err
}

const upsertMarsInfo = `-- name: UpsertMarsInfo :exec
INSERT INTO mars_info (group_id, pic_dhash, count, last_msg_id, in_whitelist)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(group_id, pic_dhash) DO UPDATE SET count=excluded.count,
                                               last_msg_id=excluded.last_msg_id,
                                               in_whitelist=excluded.in_whitelist
`

type UpsertMarsInfoParams struct {
	GroupID     int64  `json:"group_id"`
	PicDhash    []byte `json:"pic_dhash"`
	Count       int64  `json:"count"`
	LastMsgID   int64  `json:"last_msg_id"`
	InWhitelist int64  `json:"in_whitelist"`
}

func (q *Queries) UpsertMarsInfo(ctx context.Context, arg UpsertMarsInfoParams) error {
	var logFields []zap.Field
	var start time.Time
	if q.logger != nil {
		logFields = make([]zap.Field, 0, 8)
		start = time.Now()
		if q.LogArgument {
			logFields = append(logFields,
				zap.Dict("fields",
					zap.Int64("group_id", arg.GroupID),
					zap.ByteString("pic_dhash", arg.PicDhash),
					zap.Int64("count", arg.Count),
					zap.Int64("last_msg_id", arg.LastMsgID),
					zap.Int64("in_whitelist", arg.InWhitelist),
				),
			)
		}
	}
	_, err := q.exec(ctx, q.upsertMarsInfoStmt, upsertMarsInfo,
		arg.GroupID,
		arg.PicDhash,
		arg.Count,
		arg.LastMsgID,
		arg.InWhitelist,
	)
	q.logQuery(upsertMarsInfo, "UpsertMarsInfo", logFields, err, start)
	return err
}
